Revisão API

Riscos Críticos

Tokens de acesso e refresh nunca expiram e a estratégia Passport ignora expiração, o que mantém sessões válidas indefinidamente e expõe a API a sequestro de credenciais; além disso, o JWT_SECRET tem fallback para 'secret' e é logado em texto puro no boot e a cada validação (apps/api/src/modules/engine/auth/services/auth.service.ts:107, apps/api/src/modules/engine/auth/strategies/jwt.strategy.ts:47, apps/api/src/modules/engine/auth/auth.module.ts:16, apps/api/src/modules/engine/auth/strategies/jwt.strategy.ts:56).
Dados sensíveis (Authorization header, payload JWT, corpo das requisições, respostas completas) são enviados para stdout pelo guard e middleware globais, o que viola LGPD e torna qualquer auditoria complicada (apps/api/src/modules/engine/auth/guards/jwt-auth.guard.ts:52, apps/api/src/modules/engine/auth/guards/jwt-auth.guard.ts:81, apps/api/src/common/middleware/logger.middleware.ts:97).
O filtro global devolve o objeto de erro bruto para o cliente em falhas 500, potencialmente com stack traces e classes internas serializadas (apps/api/src/common/filters/all-exceptions.filter.ts:117).
cleanupPort mata indiscriminadamente qualquer processo na porta configurada a cada subida da API, inclusive em produção, via kill -9 (apps/api/src/main.ts:74). Isso pode encerrar serviços legítimos e viola boas práticas de orquestração.
Fragilidades de Arquitetura e DRY

O singleton manual db ignora o ciclo de vida do Nest: cria uma nova instância de DatabaseService fora do DI, portanto onModuleInit/onModuleDestroy não são disparados e o timezone nunca é configurado para essas conexões extras; múltiplos serviços podem acabar usando clientes Prisma diferentes (apps/api/src/database/database.service.ts:124, apps/api/src/modules/engine/auth/services/contract-permissions.service.ts:49).
Serviços de domínio (APR, Checklist, Veículo, Equipe etc.) duplicam a mesma estrutura de validação/paginação/auditoria, cada um mantendo suas próprias helpers mesmo já existindo utilidades compartilhadas; isso aumenta custo de manutenção e risco de divergência (ex.: apps/api/src/modules/checklist/services/checklist.service.ts:92, apps/api/src/modules/apr/services/apr.service.ts:98, apps/api/src/modules/veiculo/services/veiculo.service.ts:77, apps/api/src/modules/equipe/services/equipe.service.ts:77).
Comentários excessivamente verbosos (blocos enormes em quase cada método) dificultam a leitura do código real e escondem problemas; preferir documentação enxuta e focada apenas onde agrega contexto.
Pontos Fortes

Estrutura modular bem segmentada com import/export claros no AppModule e uso consistente de DTOs com class-validator/class-transformer.
Validação global (ValidationPipe com whitelist e forbidNonWhitelisted) e filtros centralizados mostram preocupação com robustez.
Há utilidades compartilhadas para paginação, validação e auditoria (apps/api/src/common/utils), o que aponta para uma intenção de padronização.
Testes e Observabilidade

Cobertura atual é mínima (um spec unitário do AppController e um e2e gerado pelo Nest) e não toca caminhos críticos como autenticação, permissões, fluxos de sincronização (apps/api/test/app.e2e-spec.ts:1, apps/api/src/app.controller.spec.ts:1). Faltam testes para os serviços core e guard/strategy.
Logging hoje é ruidoso (muito console.log/console.error, emoji, payloads completos). Substituir por Logger com níveis controlados e mascaramento de dados sensíveis ajudaria em produção.
Sugestões de Refatoração

Endurecer autenticação: exigir JWT_SECRET via config segura, definir expiresIn para access/refresh tokens, parar de logar segredos/payloads e implementar persistência segura de refresh tokens (hash + revogação). Ajustar JwtStrategy/JwtAuthGuard para logs minimalistas.
Substituir cleanupPort por abordagem específica de desenvolvimento (script opcional) e nunca executar em produção; remover abortOnError: false para evitar subir com dependências quebradas.
Reescrever o acesso ao Prisma para depender exclusivamente de um DatabaseService/PrismaService original do Nest (sem Proxy global) e mover qualquer cache/consulta para serviços que recebem essa dependência via DI.
Consolidar o padrão dos serviços de domínio: criar helpers compartilhados para montar cláusulas de busca, auditoria e paginação; reduzir logging repetitivo e alinhar validações reutilizando @common/utils.
Revisar AllExceptionsFilter para serializar apenas mensagens sanitizadas e registrar stack trace em log privado.
Planejar suíte mínima de testes cobrindo AuthService, ContractPermissionsService, guards/decorators e pelo menos um fluxo completo de cada agregado (APR, Checklist, Veículo) com happy path + cenários de erro.
Próximos Passos

Priorizar correções de segurança (tokens/segredos/logging) e remover rotinas destrutivas de boot.
Reestruturar acesso ao banco e consolidar helpers/serviços base.
Adicionar testes automatizados cobrindo autenticação e permissões antes do deploy.




Auto context


Local

Agent (full access)

gpt-5-codex
high
